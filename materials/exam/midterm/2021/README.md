# 2021

### Q1. Describe what is "user mode" and "kernel mode". Why operating system needs dual mode.

User mode 僅能使用電腦的部分操作，主要為應用層面上的部分。Kernel mode 則可以操作大部分電腦的硬體和系統功能。

Dual mode 的目的是可以加強 OS 的安全性。

### Q3. Answer the following questions about interrupt.

- (A) What is the interrupt Service Routine (ISR)?
- (B) Describe how a processor deals with interrupts.
- (C) Describe the difference between interrupt and trap.

Ans:

- (A) 由 vector 指向 ISR, ISR 存中斷處理即常見的 interrupt 要求。
- (B) 將 process 的狀態變數等等狀態存起來然後載入 interrupt 進來的 ISR 做完後交還。
- (C) 
  - Trap: 軟體產生。System call an exception in a user process. e.g. system call (software divide-by-zero)
  - Interrupt: 硬體產生 Signal。Something generated by the hardware. e.g. I/O-complete interrupt (hardware generated)

### Q4. Draw the process state transition diagram

![](./image-1.png)

### Q5. Describe why direct memeory access (DMA) is considered an efficient mechanism for performing I/O.

因為 DMA 可以令 CPU 不用介入傳資料的過程，所以可以更有效率地在 I/O 設備和記憶體之間傳遞大量資料。

### Q6. There are many parts in process. They are text section, stack, data section, heap, program counter and some processor registers.

- (A) Please describe all of the above respectively.
  - Text Section has the program code.
  - Program counter 會指向現在執行到哪一條指令。
  - Stack 存許多暫存資料，包含 function parameters, return addresses, local variables。
  - Data section 包含 global variables。
  - Heap 動態配置記憶體。
- (B) Please draw a memory layout of the process.
  ```
    +----------------+ max
    | Stack          |
    |                |
    +----------------+
    | Heap           |
    +----------------+
    | Data Section   |
    +----------------+
    | Text Section   |
    +----------------+ 0
  ```

### Q7. Please compare with ordinary pipes and named pipes.

- Ordinary pipes: 除了創造這個程序的城市以外都不能存取，通常用來說是負程序新增一個 pipe 之後用來和該父程序之子程序溝通，並且是單向通訊的。
- Named pipes: 不受父子程序的限制，都可以存取，並且是雙向通訊的。

### Q8. Compare to single thread process, what are the benefits of multi-thread? (at least three points of view)

- Responsiveness
- Resource sharing
- Economy
- Scalability

### Q9. Describe the differences between physical, virtual, and logical memory.

- Physical memory: 電腦實體的記憶體
- Virtual memory: 通過使用硬碟作為主記憶體之外延伸的記憶體，讓處理器可以執行比實體記憶體空間還大的城市的方法。
- Logical memory: 是一個抽象化的記憶體方法，讓程式設計師與應用程式簡化使用記憶體規劃的方式，不用擔心記憶體的大小限制。

### Q10. Please describe thread pools and list two advatages about it.

是先建立數個 Threads 將它們放在 pool 中，當有 task 進來時，就可以直接從中挑選 thread 來做事。
- 比起遇到 task 才建立 thread 能更快地給予服務。
- 可以更好地控制 thread 的數量，避免過多的 thread 造成資源浪費。
- 將 thread 和 task 分離，這樣能更好地控制 thread 排程的機制。

### Q11. Describe three general methods used to pass parameters to the operating system during system calls

1. Register
2. Memory
3. Stack

### Q12. What is a context switch? How does it work?

當 CPU 切換至其他行程，透過 Context Switch，系統會儲存當前行程狀態並載入新行程狀態。Context switch 發生，將當前 process 相關資訊、狀態 (context) 存於 PCB 中 (process 及其 CPU 存入 memory) ，並將下一個 schedule 的形成及其 PCB 載入 kernel 執行。

### Q13. How many processes including the parent process would be created by the following code?

```c
int main() {
    if (fork() == 0) {
        fork();
        fork();
        fork();
    }
}
```

9

### Q14. For the CPU scheduling algorithm with priority, the starvation problem may occur. Explain how "aging" can be used to prevent it?

Aging: 隨著 process 待在系統的時間逐漸增加，系統也逐步調高其優先權，經過一段時間後，其優先權會變成最高，所以可以取得資源並完成工作。

1. **Aging:** fixed priority scheduling is a scheduling discipline, in which tasks queued for utilizing a system resource are assigned a priority each.
2. Set the **TIME QUANTUM** for each process avoid to unfairly utilize CPU time.

### Q15. What will dispatcher module do? (List three points of view)

1. Switching context
2. Switching to user mode
3. Jumping to the proper location in the user program to restart that program

### Q16. Please explain three kinds of multithreading models, one-to-one, many-to-one, and many-to-many, respectively.

- One-to-one:
  - Each user-level thread maps to kernel thread
  - Creating a user-level thread creates a kernel thread
  - More concurrency than many-to-one
  - Number of threads per process sometimes restricted due to overhead
- Many-to-one:
  - Many user-level threads mapped to single kernel thread
  - One thread blocking causes all to block
  - Multiple threads may not run in parallel on multicore system because only one may be in kernel at a time
  - Few systems currently use this model
- Many-to-Many:
  - Allows many user level threads to be mapped to many kernel threads
  - Allows the operating system to create a sufficient number of kernel threads.

### Q17. Please draw the Gantt and calculate the average waiting time for the following processes for the problems shown below.

- (A) First-Come, First-Served (FCFS)
- (B) Round Robin (RR), time quantum = 4
- (C) Preemptive shortest-remaining-time-first (SRTF)

| Process | Arrival Time | Burst Time |
| ------- | ------------ | ---------- |
| P1      | 0            | 10          |
| P2      | 2            | 6           |
| P3      | 23           | 1           |
| P4      | 3            | 5           |

